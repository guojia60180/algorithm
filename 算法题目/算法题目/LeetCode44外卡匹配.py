#Author guo
'''
开始进行匹配，若i小于s串的长度，
进行while循环。若当前两个字符相等，
或着p中的字符是问号，则i和j分别加1。若p[j] 是星号，
那么我们要记录星号的位置，
pStar赋为j，此时j再自增1，iStar赋为i。
若当前p[j] 不是星号，并且不能跟p[i] 匹配上，那么此时就要靠星号了，
若之前星号没出现过，那么就直接跪，
比如 s = "aa" 和 p = "c*"，此时 s[0] 和 p[0] 无法匹配，
虽然p[1] 是星号，但还是跪。
如果星号之前出现过，可以强行续一波命，比如 s = "aa" 和 p = "*c"，
当发现 s[1] 和 p[1] 无法匹配时，但是好在之前 p[0] 出现了星号，
我们把 s[1] 交给 p[0] 的星号去匹配。
至于如何知道之前有没有星号，这时就能看出 iStar 的作用了，
因为其初始化为-1，而遇到星号时，其就会被更新为i，
那么我们只要检测 iStar 的值，就能知道是否可以使用星号续命。
虽然成功续了命，匹配完了s中的所有字符
，但是之后我们还要检查p串，此时没匹配完的p串里只能剩星号，
不能有其他的字符，将连续的星号过滤掉，如果j不等于p的长度，则返回false
'''