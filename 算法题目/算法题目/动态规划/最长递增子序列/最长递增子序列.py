#Author guo
'''
方法思想： 
为了求出该数组的最长递增子序列，就需要先求出在以数组中每个元素为结尾的情况下，最长的递增子序列是什么样的。因此首先要申请一块二维数组空间，存放以各个元素为结尾情况下的最长递增子序列。

首先显然可知，以0号元素为结尾的子序列只有0号元素自己。然后计算以1号元素为结尾的子序列，以此类推。

当计算n号的元素对应的子序列时，可以用n号元素与n-1号子序列的末尾元素比较，若n号元素大，则n号元素 暂时 求出的子序列就是n-1号元素对应子序列再加上n号元素。然后，将n号元素与n-2号元素对应子序列做同样对比，依次计算下去，选择一个可以使n号元素的子序列最长的情况。

按照上述方法，依次计算每个元素对应的结果之后的子序列，选择一个长度最长的序列即为整个数组的最长递增子序列。 
按照同样的道理可以求出最长递减子序列。

举例说明上述思想： 
对于序列A{35, 36, 39, 3, 15, 27, 6, 42}当处理到最后一个元素42时，以35， 36， 39， 3， 15， 27， 6为最末元素的最长递增序列分别为： 
35 
35，36 
35，36，39 
3 
3，15 
3，15，27 
3，6 
下面来计算42元素对应的子序列，首先将42与上述子序列末尾元素比较大小，小于42时，将42加入上述序列末尾，比较各个序列的长度，选择长度最长的，如下： 
35，42 
35，36，42 
35，36，39，42， 
3，42 
3，15，42 
3，15，27，42 
3，6，42 
这其中最长的递增序列为(35，36，39，42)和(3，15，27，42)，所以序列A的最长递增子序列的长度为4，在A中长度为4的递增子序列不止一个。 
则整个数组的最长递增子序列长度为4。
可以使用二分查找，将每一个数字的插入时间优化到O(logN)于是算法的时间复杂度就降低到了O(NlogN)
'''
def lis(B,d,n):
    left=right=mid=len=1
    B[0]=d[0]
    for i in range(1,n):
        left=0
        right=len
        while left<=right:
            mid=(left+right)//2
            if B[mid]<d[i]:
                left=mid+1
            else:
                right=mid-1

            B[left]=d[i]
            if left>len:
                len+=1
    return len
def getdp1(arr):
    n = len(arr)
    dp = [0] * n
    for i in range(n):
        dp[i] = 1
        for j in range(i):
            if arr[i] > arr[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return dp
def generateLIS(arr, dp):
    n = max(dp)
    index = dp.index(n)
    lis = [0] * n
    n -= 1
    lis[n] = arr[index]
    # 从右向左
    for i in range(index, 0 - 1, -1):
        # 关键
        if arr[i] < arr[index] and dp[i] == dp[index] - 1:
            n -= 1
            lis[n] = arr[i]
            index = i
    return lis
if __name__ == '__main__':
    d=[2,1,5,3,6,4,8,9,7]
    B=[0]*len(d)
    print(lis(B,d,len(d)))